{"version":3,"file":"gridList.js","sourceRoot":"","sources":["../../../../../../../projects/angular2gridster/src/lib/gridList/gridList.ts"],"names":[],"mappings":"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","sourcesContent":["import { GridListItem } from './GridListItem';\r\nimport { IGridsterOptions } from '../IGridsterOptions';\r\n\r\nconst makeGridCol = function (lanes: number): GridCol {\r\n    let result: GridListItem[] = [];\r\n    for (let i = 0; i < lanes; i++) {\r\n        result.push(null);\r\n    }\r\n    return result;\r\n};\r\n\r\ntype GridCol = GridListItem[];\r\n\r\n/**\r\n * A GridList manages the two-dimensional positions from a list of items,\r\n * within a virtual matrix.\r\n *\r\n * The GridList's main function is to convert the item positions from one\r\n * grid size to another, maintaining as much of their order as possible.\r\n *\r\n * The GridList's second function is to handle collisions when moving an item\r\n * over another.\r\n *\r\n * The positioning algorithm places items in columns. Starting from left to\r\n * right, going through each column top to bottom.\r\n *\r\n * The size of an item is expressed using the number of cols and rows it\r\n * takes up within the grid (w and h)\r\n *\r\n * The position of an item is express using the col and row position within\r\n * the grid (x and y)\r\n *\r\n * An item is an object of structure:\r\n * {\r\n   *   w: 3, h: 1,\r\n   *   x: 0, y: 1\r\n   * }\r\n */\r\nexport class GridList {\r\n    items: Array<GridListItem>;\r\n    grid: Array<Array<GridListItem>>;\r\n\r\n    options: IGridsterOptions;\r\n\r\n    constructor(items: Array<GridListItem>, options: IGridsterOptions) {\r\n        this.options = options;\r\n\r\n        this.items = items;\r\n\r\n        this.adjustSizeOfItems();\r\n\r\n        this.generateGrid();\r\n    }\r\n\r\n    /**\r\n     * Illustrates grid as text-based table, using a number identifier for each\r\n     * item. E.g.\r\n     *\r\n     *  #|  0  1  2  3  4  5  6  7  8  9 10 11 12 13\r\n     *  --------------------------------------------\r\n     *  0| 00 02 03 04 04 06 08 08 08 12 12 13 14 16\r\n     *  1| 01 -- 03 05 05 07 09 10 11 11 -- 13 15 --\r\n     *\r\n     * Warn: Does not work if items don't have a width or height specified\r\n     * besides their position in the grid.\r\n     */\r\n    toString() {\r\n        const widthOfGrid = this.grid.length;\r\n        let output = '\\n #|',\r\n            border = '\\n --',\r\n            item,\r\n            i,\r\n            j;\r\n\r\n        // Render the table header\r\n        for (i = 0; i < widthOfGrid; i++) {\r\n            output += ' ' + this.padNumber(i, ' ');\r\n            border += '---';\r\n        }\r\n        output += border;\r\n\r\n        // Render table contents row by row, as we go on the y axis\r\n        for (i = 0; i < this.options.lanes; i++) {\r\n            output += '\\n' + this.padNumber(i, ' ') + '|';\r\n            for (j = 0; j < widthOfGrid; j++) {\r\n                output += ' ';\r\n                item = this.grid[j][i];\r\n                output += item ? this.padNumber(this.items.indexOf(item), '0') : '--';\r\n            }\r\n        }\r\n        output += '\\n';\r\n        return output;\r\n    }\r\n\r\n    setOption(name: keyof IGridsterOptions, value: any) {\r\n        this.options[name] = value;\r\n    }\r\n\r\n    /**\r\n     * Build the grid structure from scratch, with the current item positions\r\n     */\r\n    generateGrid() {\r\n        let i;\r\n        this.resetGrid();\r\n        for (i = 0; i < this.items.length; i++) {\r\n            this.markItemPositionToGrid(this.items[i]);\r\n        }\r\n    }\r\n\r\n    resizeGrid(lanes: number) {\r\n        let currentColumn = 0;\r\n\r\n        this.options.lanes = lanes;\r\n        this.adjustSizeOfItems();\r\n\r\n        this.sortItemsByPosition();\r\n        this.resetGrid();\r\n\r\n        // The items will be sorted based on their index within the this.items array,\r\n        // that is their \"1d position\"\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            const item = this.items[i],\r\n                position = this.getItemPosition(item);\r\n\r\n            this.updateItemPosition(\r\n                item, this.findPositionForItem(item, {x: currentColumn, y: 0}));\r\n\r\n            // New items should never be placed to the left of previous items\r\n            currentColumn = Math.max(currentColumn, position.x);\r\n        }\r\n\r\n        this.pullItemsToLeft();\r\n    }\r\n\r\n    /**\r\n     * This method has two options for the position we want for the item:\r\n     * - Starting from a certain row/column number and only looking for\r\n     *   positions to its right\r\n     * - Accepting positions for a certain row number only (use-case: items\r\n     *   being shifted to the left/right as a result of collisions)\r\n     *\r\n     * @param Object item\r\n     * @param Object start Position from which to start\r\n     *     the search.\r\n     * @param number [fixedRow] If provided, we're going to try to find a\r\n     *     position for the new item on it. If doesn't fit there, we're going\r\n     *     to put it on the first row.\r\n     *\r\n     * @returns Array x and y.\r\n     */\r\n    findPositionForItem(item: GridListItem, start: { x: number, y: number }, fixedRow?: number): [number, number] {\r\n        let x, y, position: [number, number];\r\n\r\n        // Start searching for a position from the horizontal position of the\r\n        // rightmost item from the grid\r\n        for (x = start.x; x < this.grid.length; x++) {\r\n            if (fixedRow !== undefined) {\r\n                position = [x, fixedRow];\r\n\r\n                if (this.itemFitsAtPosition(item, position)) {\r\n                    return position;\r\n                }\r\n            } else {\r\n                for (y = start.y; y < this.options.lanes; y++) {\r\n                    position = [x, y];\r\n\r\n                    if (this.itemFitsAtPosition(item, position)) {\r\n                        return position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // If we've reached this point, we need to start a new column\r\n        const newCol = this.grid.length;\r\n        let newRow = 0;\r\n\r\n        if (fixedRow !== undefined &&\r\n            this.itemFitsAtPosition(item, [newCol, fixedRow])) {\r\n            newRow = fixedRow;\r\n        }\r\n\r\n        return [newCol, newRow];\r\n    }\r\n\r\n    moveAndResize(item: GridListItem, newPosition: Array<number>, size: { w: number, h: number }) {\r\n        const position = this.getItemPosition({\r\n            x: newPosition[0],\r\n            y: newPosition[1],\r\n            w: item.w,\r\n            h: item.h\r\n        });\r\n        const width = size.w || item.w,\r\n            height = size.h || item.h;\r\n\r\n\r\n        this.updateItemPosition(item, [position.x, position.y]);\r\n        this.updateItemSize(item, width, height);\r\n\r\n        this.resolveCollisions(item);\r\n    }\r\n\r\n    moveItemToPosition(item: GridListItem, newPosition: Array<number>) {\r\n        const position = this.getItemPosition({\r\n            x: newPosition[0],\r\n            y: newPosition[1],\r\n            w: item.w,\r\n            h: item.h\r\n        });\r\n\r\n        this.updateItemPosition(item, [position.x, position.y]);\r\n        this.resolveCollisions(item);\r\n    }\r\n\r\n    /**\r\n     * Resize an item and resolve collisions.\r\n     *\r\n     * @param Object item A reference to an item that's part of the grid.\r\n     * @param Object size\r\n     * @param number [size.w=item.w] The new width.\r\n     * @param number [size.h=item.h] The new height.\r\n     */\r\n    resizeItem(item: GridListItem, size: { w: number, h: number }) {\r\n        const width = size.w || item.w,\r\n            height = size.h || item.h;\r\n\r\n        this.updateItemSize(item, width, height);\r\n\r\n        this.pullItemsToLeft(item);\r\n    }\r\n\r\n    /**\r\n     * Compare the current items against a previous snapshot and return only\r\n     * the ones that changed their attributes in the meantime. This includes both\r\n     * position (x, y) and size (w, h)\r\n     *\r\n     * Each item that is returned is not the GridListItem but the helper that holds GridListItem\r\n     * and list of changed properties.\r\n     */\r\n    getChangedItems(initialItems: Array<GridListItem>, breakpoint?: string): Array<{\r\n        item: GridListItem, changes: Array<string>, isNew: boolean\r\n    }> {\r\n\r\n        return this.items.map((item: GridListItem) => {\r\n            const changes = [];\r\n            const oldValues: {x?: number, y?: number, w?: number, h?: number} = {};\r\n            const initItem = initialItems.find(initItm => initItm.$element === item.$element);\r\n\r\n            if (!initItem) {\r\n                return {item, changes: ['x', 'y', 'w', 'h'], isNew: true};\r\n            }\r\n\r\n            const oldX = initItem.getValueX(breakpoint);\r\n            if (item.getValueX(breakpoint) !== oldX) {\r\n                changes.push('x');\r\n                if (oldX) {\r\n                    oldValues.x = oldX;\r\n                }\r\n            }\r\n\r\n            const oldY = initItem.getValueY(breakpoint);\r\n            if (item.getValueY(breakpoint) !== oldY) {\r\n                changes.push('y');\r\n                if (oldY) {\r\n                    oldValues.y = oldY;\r\n                }\r\n            }\r\n            if (item.getValueW(breakpoint) !== initItem.getValueW(breakpoint)) {\r\n                changes.push('w');\r\n                oldValues.w = initItem.w;\r\n            }\r\n            if (item.getValueH(breakpoint) !== initItem.getValueH(breakpoint)) {\r\n                changes.push('h');\r\n                oldValues.h = initItem.h;\r\n            }\r\n\r\n            return {item, oldValues, changes, isNew: false};\r\n        })\r\n            .filter((itemChange: { item: GridListItem, changes: Array<string> }) => {\r\n                return itemChange.changes.length;\r\n            });\r\n    }\r\n\r\n    resolveCollisions(item: GridListItem) {\r\n        if (!this.tryToResolveCollisionsLocally(item)) {\r\n            this.pullItemsToLeft(item);\r\n        }\r\n        if (this.options.floating) {\r\n            this.pullItemsToLeft();\r\n        } else if (this.getItemsCollidingWithItem(item).length) {\r\n            this.pullItemsToLeft();\r\n        }\r\n    }\r\n\r\n    pushCollidingItems(fixedItem?: GridListItem) {\r\n        // Start a fresh grid with the fixed item already placed inside\r\n        this.sortItemsByPosition();\r\n        this.resetGrid();\r\n        this.generateGrid();\r\n\r\n        this.items\r\n            .filter((item) => (!this.isItemFloating(item) && item !== fixedItem))\r\n            .forEach((item) => {\r\n                if (!this.tryToResolveCollisionsLocally(item)) {\r\n                    this.pullItemsToLeft(item);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Build the grid from scratch, by using the current item positions and\r\n     * pulling them as much to the left as possible, removing as space between\r\n     * them as possible.\r\n     *\r\n     * If a \"fixed item\" is provided, its position will be kept intact and the\r\n     * rest of the items will be layed around it.\r\n     */\r\n    pullItemsToLeft(fixedItem?: any) {\r\n        if (this.options.direction === 'none') {\r\n            return;\r\n        }\r\n\r\n        // Start a fresh grid with the fixed item already placed inside\r\n        this.sortItemsByPosition();\r\n        this.resetGrid();\r\n\r\n        // Start the grid with the fixed item as the first positioned item\r\n        if (fixedItem) {\r\n            const fixedPosition = this.getItemPosition(fixedItem);\r\n            this.updateItemPosition(fixedItem, [fixedPosition.x, fixedPosition.y]);\r\n        }\r\n\r\n        this.items\r\n            .filter((item: GridListItem) => {\r\n                return !item.dragAndDrop && item !== fixedItem;\r\n            })\r\n            .forEach((item: GridListItem) => {\r\n                const fixedPosition = this.getItemPosition(item);\r\n                this.updateItemPosition(item, [fixedPosition.x, fixedPosition.y]);\r\n            });\r\n\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            const item = this.items[i],\r\n                position = this.getItemPosition(item);\r\n\r\n            // The fixed item keeps its exact position\r\n            if (fixedItem && item === fixedItem ||\r\n                !item.dragAndDrop ||\r\n                (!this.options.floating && this.isItemFloating(item) && !this.getItemsCollidingWithItem(item).length)) {\r\n                continue;\r\n            }\r\n\r\n            const x = this.findLeftMostPositionForItem(item),\r\n                newPosition = this.findPositionForItem(\r\n                    item, {x: x, y: 0}, position.y);\r\n\r\n            this.updateItemPosition(item, newPosition);\r\n        }\r\n    }\r\n\r\n    isOverFixedArea(x: number, y: number, w: number, h: number, item: GridListItem = null): boolean {\r\n        let itemData = {x, y, w, h};\r\n\r\n        if (this.options.direction !== 'horizontal') {\r\n            itemData = {x: y, y: x, w: h, h: w};\r\n        }\r\n\r\n        for (let i = itemData.x; i < itemData.x + itemData.w; i++) {\r\n            for (let j = itemData.y; j < itemData.y + itemData.h; j++) {\r\n                if (this.grid[i] && this.grid[i][j] &&\r\n                    this.grid[i][j] !== item && !this.grid[i][j].dragAndDrop) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    checkItemAboveEmptyArea(item: GridListItem, newPosition: { x: number, y: number }) {\r\n        let itemData = {\r\n            x: newPosition.x,\r\n            y: newPosition.y,\r\n            w: item.w,\r\n            h: item.h\r\n        };\r\n        if (!item.itemPrototype && item.x === newPosition.x && item.y === newPosition.y) {\r\n            return true;\r\n        }\r\n\r\n        if (this.options.direction === 'horizontal') {\r\n            itemData = {x: newPosition.y, y: newPosition.x, w: itemData.h, h: itemData.w};\r\n        }\r\n        return !this.checkItemsInArea(\r\n            itemData.y,\r\n            itemData.y + itemData.h - 1,\r\n            itemData.x,\r\n            itemData.x + itemData.w - 1,\r\n            item\r\n        );\r\n    }\r\n\r\n    fixItemsPositions(options: IGridsterOptions) {\r\n        // items with x, y that fits gird with size of options.lanes\r\n        const validItems = this.items\r\n            .filter((item: GridListItem) => item.itemComponent)\r\n            .filter((item: GridListItem) => this.isItemValidForGrid(item, options));\r\n        // items that x, y must be generated\r\n        const invalidItems = this.items\r\n            .filter((item: GridListItem) => item.itemComponent)\r\n            .filter((item: GridListItem) => !this.isItemValidForGrid(item, options));\r\n\r\n        const gridList = new GridList([], options);\r\n\r\n        // put items with defined positions to the grid\r\n        gridList.items = validItems\r\n            .map((item: GridListItem) => {\r\n                return item.copyForBreakpoint(options.breakpoint);\r\n            });\r\n\r\n        gridList.generateGrid();\r\n\r\n        invalidItems.forEach((item) => {\r\n            // TODO: check if this change does not broke anything\r\n            // const itemCopy = item.copy();\r\n            const itemCopy = item.copyForBreakpoint(options.breakpoint);\r\n            const position = gridList.findPositionForItem(itemCopy, {x: 0, y: 0});\r\n\r\n            gridList.items.push(itemCopy);\r\n            gridList.setItemPosition(itemCopy, position);\r\n            gridList.markItemPositionToGrid(itemCopy);\r\n        });\r\n\r\n        gridList.pullItemsToLeft();\r\n        gridList.pushCollidingItems();\r\n\r\n        this.items.forEach((itm: GridListItem) => {\r\n            const cachedItem = gridList.items.filter(cachedItm => {\r\n                return cachedItm.$element === itm.$element;\r\n            })[0];\r\n\r\n            itm.setValueX(cachedItem.x, options.breakpoint);\r\n            itm.setValueY(cachedItem.y, options.breakpoint);\r\n            itm.setValueW(cachedItem.w, options.breakpoint);\r\n            itm.setValueH(cachedItem.h, options.breakpoint);\r\n            itm.autoSize = cachedItem.autoSize;\r\n        });\r\n    }\r\n\r\n    deleteItemPositionFromGrid(item: GridListItem) {\r\n        const position = this.getItemPosition(item);\r\n        let x, y;\r\n\r\n        for (x = position.x; x < position.x + position.w; x++) {\r\n            // It can happen to try to remove an item from a position not generated\r\n            // in the grid, probably when loading a persisted grid of items. No need\r\n            // to create a column to be able to remove something from it, though\r\n            if (!this.grid[x]) {\r\n                continue;\r\n            }\r\n\r\n            for (y = position.y; y < position.y + position.h; y++) {\r\n                // Don't clear the cell if it's been occupied by a different widget in\r\n                // the meantime (e.g. when an item has been moved over this one, and\r\n                // thus by continuing to clear this item's previous position you would\r\n                // cancel the first item's move, leaving it without any position even)\r\n                if (this.grid[x][y] === item) {\r\n                    this.grid[x][y] = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private isItemFloating(item: any) {\r\n        if (item.itemComponent && item.itemComponent.isDragging) {\r\n            return false;\r\n        }\r\n        const position = this.getItemPosition(item);\r\n\r\n        if (position.x === 0) {\r\n            return false;\r\n        }\r\n        const rowBelowItem = this.grid[position.x - 1];\r\n\r\n        return (rowBelowItem || [])\r\n            .slice(position.y, position.y + position.h)\r\n            .reduce((isFloating, cellItem) => {\r\n                return isFloating && !cellItem;\r\n            }, true);\r\n    }\r\n\r\n    private isItemValidForGrid(item: GridListItem, options: IGridsterOptions) {\r\n        const itemData = options.direction === 'horizontal' ? {\r\n            x: item.getValueY(options.breakpoint),\r\n            y: item.getValueX(options.breakpoint),\r\n            w: item.getValueH(options.breakpoint),\r\n            h: Math.min(item.getValueW(this.options.breakpoint), options.lanes)\r\n        } : {\r\n            x: item.getValueX(options.breakpoint),\r\n            y: item.getValueY(options.breakpoint),\r\n            w: Math.min(item.getValueW(this.options.breakpoint), options.lanes),\r\n            h: item.getValueH(options.breakpoint)\r\n        };\r\n\r\n        return typeof itemData.x === 'number' &&\r\n            typeof itemData.y === 'number' &&\r\n            (itemData.x + itemData.w) <= options.lanes;\r\n    }\r\n\r\n    public findDefaultPositionHorizontal(width: number, height: number) {\r\n        for (const col of this.grid) {\r\n            const colIdx = this.grid.indexOf(col);\r\n            let rowIdx = 0;\r\n            while (rowIdx < (col.length - height + 1)) {\r\n                if (!this.checkItemsInArea(colIdx, colIdx + width - 1, rowIdx, rowIdx + height - 1)) {\r\n                    return [colIdx, rowIdx];\r\n                }\r\n                rowIdx++;\r\n            }\r\n        }\r\n        return [this.grid.length, 0];\r\n    }\r\n\r\n    public findDefaultPositionVertical(width: number, height: number) {\r\n\r\n        for (const row of this.grid) {\r\n            const rowIdx = this.grid.indexOf(row);\r\n            let colIdx = 0;\r\n            while (colIdx < (row.length - width + 1)) {\r\n                if (!this.checkItemsInArea(rowIdx, rowIdx + height - 1, colIdx, colIdx + width - 1)) {\r\n                    return [colIdx, rowIdx];\r\n                }\r\n                colIdx++;\r\n            }\r\n        }\r\n        return [0, this.grid.length];\r\n    }\r\n\r\n    private checkItemsInArea(rowStart: number, rowEnd: number, colStart: number, colEnd: number, item?: GridListItem) {\r\n        for (let i = rowStart; i <= rowEnd; i++) {\r\n            for (let j = colStart; j <= colEnd; j++) {\r\n                if (this.grid[i] && this.grid[i][j] && (item ? this.grid[i][j] !== item : true)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private sortItemsByPosition() {\r\n        this.items.sort((item1, item2) => {\r\n            const position1 = this.getItemPosition(item1),\r\n                position2 = this.getItemPosition(item2);\r\n\r\n            // Try to preserve columns.\r\n            if (position1.x !== position2.x) {\r\n                return position1.x - position2.x;\r\n            }\r\n\r\n            if (position1.y !== position2.y) {\r\n                return position1.y - position2.y;\r\n            }\r\n\r\n            // The items are placed on the same position.\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Some items can have 100% height or 100% width. Those dimmensions are\r\n     * expressed as 0. We need to ensure a valid width and height for each of\r\n     * those items as the number of items per lane.\r\n     */\r\n    private adjustSizeOfItems() {\r\n\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            const item = this.items[i];\r\n\r\n            // This can happen only the first time items are checked.\r\n            // We need the property to have a value for all the items so that the\r\n            // `cloneItems` method will merge the properties properly. If we only set\r\n            // it to the items that need it then the following can happen:\r\n            //\r\n            // cloneItems([{id: 1, autoSize: true}, {id: 2}],\r\n            //            [{id: 2}, {id: 1, autoSize: true}]);\r\n            //\r\n            // will result in\r\n            //\r\n            // [{id: 1, autoSize: true}, {id: 2, autoSize: true}]\r\n            if (item.autoSize === undefined) {\r\n                item.autoSize = item.w === 0 || item.h === 0;\r\n            }\r\n\r\n            if (item.autoSize) {\r\n                if (this.options.direction === 'horizontal') {\r\n                    item.h = this.options.lanes;\r\n                } else {\r\n                    item.w = this.options.lanes;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private resetGrid() {\r\n        this.grid = [];\r\n    }\r\n\r\n    /**\r\n     * Check that an item wouldn't overlap with another one if placed at a\r\n     * certain position within the grid\r\n     */\r\n    private itemFitsAtPosition(item: GridListItem, newPosition: [number, number]) {\r\n\r\n        const position = this.getItemPosition(item);\r\n        let x, y;\r\n\r\n        // No coordonate can be negative\r\n        if (newPosition[0] < 0 || newPosition[1] < 0) {\r\n            return false;\r\n        }\r\n\r\n        // Make sure the item isn't larger than the entire grid\r\n        if (newPosition[1] + Math.min(position.h, this.options.lanes) > this.options.lanes) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isOverFixedArea(item.x, item.y, item.w, item.h)) {\r\n            return false;\r\n        }\r\n\r\n        // Make sure the position doesn't overlap with an already positioned\r\n        // item.\r\n        for (x = newPosition[0]; x < newPosition[0] + position.w; x++) {\r\n            const col = this.grid[x];\r\n            // Surely a column that hasn't even been created yet is available\r\n            if (!col) {\r\n                continue;\r\n            }\r\n\r\n            for (y = newPosition[1]; y < newPosition[1] + position.h; y++) {\r\n                // Any space occupied by an item can continue to be occupied by the\r\n                // same item.\r\n                if (col[y] && col[y] !== item) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private updateItemPosition(item: GridListItem, position: [number, number]) {\r\n        if (item.x !== null && item.y !== null) {\r\n            this.deleteItemPositionFromGrid(item);\r\n        }\r\n\r\n        this.setItemPosition(item, position);\r\n\r\n        this.markItemPositionToGrid(item);\r\n    }\r\n\r\n    /**\r\n     * @param Object item A reference to a grid item.\r\n     * @param number width The new width.\r\n     * @param number height The new height.\r\n     */\r\n    private updateItemSize(item: GridListItem, width: number, height: number) {\r\n        if (item.x !== null && item.y !== null) {\r\n            this.deleteItemPositionFromGrid(item);\r\n        }\r\n\r\n        item.w = width;\r\n        item.h = height;\r\n\r\n        this.markItemPositionToGrid(item);\r\n    }\r\n\r\n    /**\r\n     * Mark the grid cells that are occupied by an item. This prevents items\r\n     * from overlapping in the grid\r\n     */\r\n    private markItemPositionToGrid(item: GridListItem) {\r\n\r\n        const position = this.getItemPosition(item);\r\n        let x, y;\r\n\r\n        // Ensure that the grid has enough columns to accomodate the current item.\r\n        this.ensureColumns(position.x + position.w);\r\n\r\n        for (x = position.x; x < position.x + position.w; x++) {\r\n            for (y = position.y; y < position.y + position.h; y++) {\r\n                this.grid[x][y] = item;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure that the grid has at least N columns available.\r\n     */\r\n    private ensureColumns(N: number) {\r\n        for (let i = 0; i < N; i++) {\r\n            if (!this.grid[i]) {\r\n                this.grid.push(makeGridCol(this.options.lanes));\r\n            }\r\n        }\r\n    }\r\n\r\n    private getItemsCollidingWithItem(item: GridListItem): number[] {\r\n        const collidingItems = [];\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (item !== this.items[i] &&\r\n                this.itemsAreColliding(item, this.items[i])) {\r\n                collidingItems.push(i);\r\n            }\r\n        }\r\n        return collidingItems;\r\n    }\r\n\r\n    private itemsAreColliding(item1: GridListItem, item2: GridListItem) {\r\n        const position1 = this.getItemPosition(item1),\r\n            position2 = this.getItemPosition(item2);\r\n\r\n        return !(position2.x >= position1.x + position1.w ||\r\n            position2.x + position2.w <= position1.x ||\r\n            position2.y >= position1.y + position1.h ||\r\n            position2.y + position2.h <= position1.y);\r\n    }\r\n\r\n    /**\r\n     * Attempt to resolve the collisions after moving an item over one or more\r\n     * other items within the grid, by shifting the position of the colliding\r\n     * items around the moving one. This might result in subsequent collisions,\r\n     * in which case we will revert all position permutations. To be able to\r\n     * revert to the initial item positions, we create a virtual grid in the\r\n     * process\r\n     */\r\n    private tryToResolveCollisionsLocally(item: GridListItem) {\r\n        const collidingItems = this.getItemsCollidingWithItem(item);\r\n        if (!collidingItems.length) {\r\n            return true;\r\n        }\r\n\r\n        const _gridList = new GridList(this.items.map(itm => {\r\n            return itm.copy();\r\n        }), this.options);\r\n\r\n        let leftOfItem: [number, number];\r\n        let rightOfItem: [number, number];\r\n        let aboveOfItem: [number, number];\r\n        let belowOfItem: [number, number];\r\n\r\n        for (let i = 0; i < collidingItems.length; i++) {\r\n            const collidingItem = _gridList.items[collidingItems[i]],\r\n                collidingPosition = this.getItemPosition(collidingItem);\r\n\r\n            // We use a simple algorithm for moving items around when collisions occur:\r\n            // In this prioritized order, we try to move a colliding item around the\r\n            // moving one:\r\n            // 1. to its left side\r\n            // 2. above it\r\n            // 3. under it\r\n            // 4. to its right side\r\n            const position = this.getItemPosition(item);\r\n\r\n            leftOfItem = [position.x - collidingPosition.w, collidingPosition.y];\r\n            rightOfItem = [position.x + position.w, collidingPosition.y];\r\n            aboveOfItem = [collidingPosition.x, position.y - collidingPosition.h];\r\n            belowOfItem = [collidingPosition.x, position.y + position.h];\r\n\r\n            if (_gridList.itemFitsAtPosition(collidingItem, leftOfItem)) {\r\n                _gridList.updateItemPosition(collidingItem, leftOfItem);\r\n            } else if (_gridList.itemFitsAtPosition(collidingItem, aboveOfItem)) {\r\n                _gridList.updateItemPosition(collidingItem, aboveOfItem);\r\n            } else if (_gridList.itemFitsAtPosition(collidingItem, belowOfItem)) {\r\n                _gridList.updateItemPosition(collidingItem, belowOfItem);\r\n            } else if (_gridList.itemFitsAtPosition(collidingItem, rightOfItem)) {\r\n                _gridList.updateItemPosition(collidingItem, rightOfItem);\r\n            } else {\r\n                // Collisions failed, we must use the pullItemsToLeft method to arrange\r\n                // the other items around this item with fixed position. This is our\r\n                // plan B for when local collision resolving fails.\r\n                return false;\r\n            }\r\n        }\r\n        // If we reached this point it means we managed to resolve the collisions\r\n        // from one single iteration, just by moving the colliding items around. So\r\n        // we accept this scenario and merge the branched-out grid instance into the\r\n        // original one\r\n\r\n        this.items.forEach((itm: GridListItem, idx: number) => {\r\n            const cachedItem = _gridList.items.filter(cachedItm => {\r\n                return cachedItm.$element === itm.$element;\r\n            })[0];\r\n\r\n            itm.x = cachedItem.x;\r\n            itm.y = cachedItem.y;\r\n            itm.w = cachedItem.w;\r\n            itm.h = cachedItem.h;\r\n            itm.autoSize = cachedItem.autoSize;\r\n        });\r\n        this.generateGrid();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * When pulling items to the left, we need to find the leftmost position for\r\n     * an item, with two considerations in mind:\r\n     * - preserving its current row\r\n     * - preserving the previous horizontal order between items\r\n     */\r\n    private findLeftMostPositionForItem(item: any) {\r\n        let tail = 0;\r\n        const position = this.getItemPosition(item);\r\n\r\n        for (let i = 0; i < this.grid.length; i++) {\r\n            for (let j = position.y; j < position.y + position.h; j++) {\r\n                const otherItem = this.grid[i][j];\r\n\r\n                if (!otherItem) {\r\n                    continue;\r\n                }\r\n\r\n                const otherPosition = this.getItemPosition(otherItem);\r\n\r\n                if (this.items.indexOf(otherItem) < this.items.indexOf(item)) {\r\n                    tail = otherPosition.x + otherPosition.w;\r\n                }\r\n            }\r\n        }\r\n\r\n        return tail;\r\n    }\r\n\r\n    public findItemByPosition(x: number, y: number): GridListItem {\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (this.items[i].x === x && this.items[i].y === y) {\r\n                return this.items[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getItemByAttribute(key: keyof GridListItem, value: any) {\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (this.items[i][key] === value) {\r\n                return this.items[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private padNumber(nr: number, prefix: string) {\r\n        // Currently works for 2-digit numbers (<100)\r\n        return nr >= 10 ? nr : prefix + nr;\r\n    }\r\n\r\n    /**\r\n     * If the direction is vertical we need to rotate the grid 90 deg to the\r\n     * left. Thus, we simulate the fact that items are being pulled to the top.\r\n     *\r\n     * Since the items have widths and heights, if we apply the classic\r\n     * counter-clockwise 90 deg rotation\r\n     *\r\n     *     [0 -1]\r\n     *     [1  0]\r\n     *\r\n     * then the top left point of an item will become the bottom left point of\r\n     * the rotated item. To adjust for this, we need to subtract from the y\r\n     * position the height of the original item - the width of the rotated item.\r\n     *\r\n     * However, if we do this then we'll reverse some actions: resizing the\r\n     * width of an item will stretch the item to the left instead of to the\r\n     * right; resizing an item that doesn't fit into the grid will push the\r\n     * items around it instead of going on a new row, etc.\r\n     *\r\n     * We found it better to do a vertical flip of the grid after rotating it.\r\n     * This restores the direction of the actions and greatly simplifies the\r\n     * transformations.\r\n     */\r\n    private getItemPosition(item: any): { x: number, y: number, w: number, h: number } {\r\n        if (this.options.direction === 'horizontal') {\r\n            return item;\r\n        } else {\r\n            return {\r\n                x: item.y,\r\n                y: item.x,\r\n                w: item.h,\r\n                h: item.w\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * See getItemPosition.\r\n     */\r\n    private setItemPosition(item: any, position: [number, number]) {\r\n\r\n        if (this.options.direction === 'horizontal') {\r\n            item.x = position[0];\r\n            item.y = position[1];\r\n        } else {\r\n            // We're supposed to subtract the rotated item's height which is actually\r\n            // the non-rotated item's width.\r\n            item.x = position[1];\r\n            item.y = position[0];\r\n        }\r\n\r\n    }\r\n}\r\n"]}