{"version":3,"file":"gridList.js","sourceRoot":"","sources":["../../../../../../../projects/angular2gridster/src/lib/gridList/gridList.ts"],"names":[],"mappings":"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","sourcesContent":["import { GridListItem } from './GridListItem';\r\nimport { IGridsterOptions } from '../IGridsterOptions';\r\n\r\n// const GridCol = function(lanes) {\r\n//     for (let i = 0; i < lanes; i++) {\r\n//         this.push(null);\r\n//     }\r\n// };\r\nconst makeGridCol = function (lanes: number): GridCol {\r\n    let result: GridListItem[] = [];\r\n    for (let i = 0; i < lanes; i++) {\r\n        result.push(null);\r\n    }\r\n    return result;\r\n};\r\n\r\ntype GridCol = GridListItem[];\r\n\r\n/**\r\n * A GridList manages the two-dimensional positions from a list of items,\r\n * within a virtual matrix.\r\n *\r\n * The GridList's main function is to convert the item positions from one\r\n * grid size to another, maintaining as much of their order as possible.\r\n *\r\n * The GridList's second function is to handle collisions when moving an item\r\n * over another.\r\n *\r\n * The positioning algorithm places items in columns. Starting from left to\r\n * right, going through each column top to bottom.\r\n *\r\n * The size of an item is expressed using the number of cols and rows it\r\n * takes up within the grid (w and h)\r\n *\r\n * The position of an item is express using the col and row position within\r\n * the grid (x and y)\r\n *\r\n * An item is an object of structure:\r\n * {\r\n *   w: 3, h: 1,\r\n *   x: 0, y: 1\r\n * }\r\n */\r\nexport class GridList {\r\n    items: Array<GridListItem>;\r\n    grid: Array<Array<GridListItem>>;\r\n\r\n    options: IGridsterOptions;\r\n\r\n    constructor(items: Array<GridListItem>, options: IGridsterOptions) {\r\n        this.options = options;\r\n\r\n        this.items = items;\r\n\r\n        this.adjustSizeOfItems();\r\n\r\n        this.generateGrid();\r\n    }\r\n\r\n    /**\r\n     * Illustrates grid as text-based table, using a number identifier for each\r\n     * item. E.g.\r\n     *\r\n     *  #|  0  1  2  3  4  5  6  7  8  9 10 11 12 13\r\n     *  --------------------------------------------\r\n     *  0| 00 02 03 04 04 06 08 08 08 12 12 13 14 16\r\n     *  1| 01 -- 03 05 05 07 09 10 11 11 -- 13 15 --\r\n     *\r\n     * Warn: Does not work if items don't have a width or height specified\r\n     * besides their position in the grid.\r\n     */\r\n    toString() {\r\n        const widthOfGrid = this.grid.length;\r\n        let output = '\\n #|',\r\n            border = '\\n --',\r\n            item,\r\n            i,\r\n            j;\r\n\r\n        // Render the table header\r\n        for (i = 0; i < widthOfGrid; i++) {\r\n            output += ' ' + this.padNumber(i, ' ');\r\n            border += '---';\r\n        }\r\n        output += border;\r\n\r\n        // Render table contents row by row, as we go on the y axis\r\n        for (i = 0; i < this.options.lanes; i++) {\r\n            output += '\\n' + this.padNumber(i, ' ') + '|';\r\n            for (j = 0; j < widthOfGrid; j++) {\r\n                output += ' ';\r\n                item = this.grid[j][i];\r\n                output += item\r\n                    ? this.padNumber(this.items.indexOf(item), '0')\r\n                    : '--';\r\n            }\r\n        }\r\n        output += '\\n';\r\n        return output;\r\n    }\r\n\r\n    setOption(name: keyof IGridsterOptions, value: any) {\r\n        (<any>this.options[name]) = value;\r\n    }\r\n\r\n    /**\r\n     * Build the grid structure from scratch, with the current item positions\r\n     */\r\n    generateGrid() {\r\n        let i;\r\n        this.resetGrid();\r\n        for (i = 0; i < this.items.length; i++) {\r\n            this.markItemPositionToGrid(this.items[i]);\r\n        }\r\n    }\r\n\r\n    resizeGrid(lanes: number) {\r\n        let currentColumn = 0;\r\n\r\n        this.options.lanes = lanes;\r\n        this.adjustSizeOfItems();\r\n\r\n        this.sortItemsByPosition();\r\n        this.resetGrid();\r\n\r\n        // The items will be sorted based on their index within the this.items array,\r\n        // that is their \"1d position\"\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            const item = this.items[i],\r\n                position = this.getItemPosition(item);\r\n\r\n            this.updateItemPosition(\r\n                item,\r\n                this.findPositionForItem(item, { x: currentColumn, y: 0 })\r\n            );\r\n\r\n            // New items should never be placed to the left of previous items\r\n            currentColumn = Math.max(currentColumn, position.x);\r\n        }\r\n\r\n        this.pullItemsToLeft();\r\n    }\r\n\r\n    /**\r\n     * This method has two options for the position we want for the item:\r\n     * - Starting from a certain row/column number and only looking for\r\n     *   positions to its right\r\n     * - Accepting positions for a certain row number only (use-case: items\r\n     *   being shifted to the left/right as a result of collisions)\r\n     *\r\n     * @param Object item\r\n     * @param Object start Position from which to start\r\n     *     the search.\r\n     * @param number [fixedRow] If provided, we're going to try to find a\r\n     *     position for the new item on it. If doesn't fit there, we're going\r\n     *     to put it on the first row.\r\n     *\r\n     * @returns Array x and y.\r\n     */\r\n    findPositionForItem(\r\n        item: GridListItem,\r\n        start: { x: number; y: number },\r\n        fixedRow?: number\r\n    ): [number, number] {\r\n        let x, y, position;\r\n\r\n        // Start searching for a position from the horizontal position of the\r\n        // rightmost item from the grid\r\n        for (x = start.x; x < this.grid.length; x++) {\r\n            if (fixedRow !== undefined) {\r\n                position = [x, fixedRow];\r\n\r\n                if (this.itemFitsAtPosition(item, position)) {\r\n                    return position;\r\n                }\r\n            } else {\r\n                for (y = start.y; y < this.options.lanes; y++) {\r\n                    position = [x, y];\r\n\r\n                    if (this.itemFitsAtPosition(item, position)) {\r\n                        return position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // If we've reached this point, we need to start a new column\r\n        const newCol = this.grid.length;\r\n        let newRow = 0;\r\n\r\n        if (\r\n            fixedRow !== undefined &&\r\n            this.itemFitsAtPosition(item, [newCol, fixedRow])\r\n        ) {\r\n            newRow = fixedRow;\r\n        }\r\n\r\n        return [newCol, newRow];\r\n    }\r\n\r\n    moveAndResize(\r\n        item: GridListItem,\r\n        newPosition: Array<number>,\r\n        size: { w: number; h: number }\r\n    ) {\r\n        const position = this.getItemPosition({\r\n            x: newPosition[0],\r\n            y: newPosition[1],\r\n            w: item.w,\r\n            h: item.h\r\n        });\r\n        const width = size.w || item.w,\r\n            height = size.h || item.h;\r\n\r\n        this.updateItemPosition(item, [position.x, position.y]);\r\n        this.updateItemSize(item, width, height);\r\n\r\n        this.resolveCollisions(item);\r\n    }\r\n\r\n    moveItemToPosition(item: GridListItem, newPosition: Array<number>) {\r\n        const position = this.getItemPosition({\r\n            x: newPosition[0],\r\n            y: newPosition[1],\r\n            w: item.w,\r\n            h: item.h\r\n        });\r\n\r\n        this.updateItemPosition(item, [position.x, position.y]);\r\n        this.resolveCollisions(item);\r\n    }\r\n\r\n    /**\r\n     * Resize an item and resolve collisions.\r\n     *\r\n     * @param Object item A reference to an item that's part of the grid.\r\n     * @param Object size\r\n     * @param number [size.w=item.w] The new width.\r\n     * @param number [size.h=item.h] The new height.\r\n     */\r\n    resizeItem(item: GridListItem, size: { w: number; h: number }) {\r\n        const width = size.w || item.w,\r\n            height = size.h || item.h;\r\n\r\n        this.updateItemSize(item, width, height);\r\n\r\n        this.pullItemsToLeft(item);\r\n    }\r\n\r\n    /**\r\n     * Compare the current items against a previous snapshot and return only\r\n     * the ones that changed their attributes in the meantime. This includes both\r\n     * position (x, y) and size (w, h)\r\n     *\r\n     * Each item that is returned is not the GridListItem but the helper that holds GridListItem\r\n     * and list of changed properties.\r\n     */\r\n    getChangedItems(\r\n        initialItems: Array<GridListItem>,\r\n        breakpoint?: string\r\n    ): Array<{\r\n        item: GridListItem;\r\n        changes: Array<string>;\r\n        isNew: boolean;\r\n    }> {\r\n        return this.items\r\n            .map((item: GridListItem) => {\r\n                const changes = [];\r\n                const oldValues: {\r\n                    x?: number;\r\n                    y?: number;\r\n                    w?: number;\r\n                    h?: number;\r\n                } = {};\r\n                const initItem = initialItems.find(\r\n                    initItm => initItm.$element === item.$element\r\n                );\r\n\r\n                if (!initItem) {\r\n                    return { item, changes: ['x', 'y', 'w', 'h'], isNew: true };\r\n                }\r\n\r\n                const oldX = initItem.getValueX(breakpoint);\r\n                if (item.getValueX(breakpoint) !== oldX) {\r\n                    changes.push('x');\r\n                    if (oldX || oldX === 0) {\r\n                        oldValues.x = oldX;\r\n                    }\r\n                }\r\n\r\n                const oldY = initItem.getValueY(breakpoint);\r\n                if (item.getValueY(breakpoint) !== oldY) {\r\n                    changes.push('y');\r\n                    if (oldY || oldY === 0) {\r\n                        oldValues.y = oldY;\r\n                    }\r\n                }\r\n                if (\r\n                    item.getValueW(breakpoint) !==\r\n                    initItem.getValueW(breakpoint)\r\n                ) {\r\n                    changes.push('w');\r\n                    oldValues.w = initItem.w;\r\n                }\r\n                if (\r\n                    item.getValueH(breakpoint) !==\r\n                    initItem.getValueH(breakpoint)\r\n                ) {\r\n                    changes.push('h');\r\n                    oldValues.h = initItem.h;\r\n                }\r\n\r\n                return { item, oldValues, changes, isNew: false };\r\n            })\r\n            .filter(\r\n                (itemChange: {\r\n                    item: GridListItem;\r\n                    changes: Array<string>;\r\n                }) => {\r\n                    return itemChange.changes.length;\r\n                }\r\n            );\r\n    }\r\n\r\n    resolveCollisions(item: GridListItem) {\r\n        if (!this.tryToResolveCollisionsLocally(item)) {\r\n            this.pullItemsToLeft(item);\r\n        }\r\n        if (this.options.floating) {\r\n            this.pullItemsToLeft();\r\n        } else if (this.getItemsCollidingWithItem(item).length) {\r\n            this.pullItemsToLeft();\r\n        }\r\n    }\r\n\r\n    pushCollidingItems(fixedItem?: GridListItem) {\r\n        // Start a fresh grid with the fixed item already placed inside\r\n        this.sortItemsByPosition();\r\n        this.resetGrid();\r\n        this.generateGrid();\r\n\r\n        this.items\r\n            .filter(item => !this.isItemFloating(item) && item !== fixedItem)\r\n            .forEach(item => {\r\n                if (!this.tryToResolveCollisionsLocally(item)) {\r\n                    this.pullItemsToLeft(item);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Build the grid from scratch, by using the current item positions and\r\n     * pulling them as much to the left as possible, removing as space between\r\n     * them as possible.\r\n     *\r\n     * If a \"fixed item\" is provided, its position will be kept intact and the\r\n     * rest of the items will be layed around it.\r\n     */\r\n    pullItemsToLeft(fixedItem?: any) {\r\n        if (this.options.direction === 'none') {\r\n            return;\r\n        }\r\n\r\n        // Start a fresh grid with the fixed item already placed inside\r\n        this.sortItemsByPosition();\r\n        this.resetGrid();\r\n\r\n        // Start the grid with the fixed item as the first positioned item\r\n        if (fixedItem) {\r\n            const fixedPosition = this.getItemPosition(fixedItem);\r\n            this.updateItemPosition(fixedItem, [\r\n                fixedPosition.x,\r\n                fixedPosition.y\r\n            ]);\r\n        }\r\n\r\n        this.items\r\n            .filter((item: GridListItem) => {\r\n                return !item.dragAndDrop && item !== fixedItem;\r\n            })\r\n            .forEach((item: GridListItem) => {\r\n                const fixedPosition = this.getItemPosition(item);\r\n                this.updateItemPosition(item, [\r\n                    fixedPosition.x,\r\n                    fixedPosition.y\r\n                ]);\r\n            });\r\n\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            const item = this.items[i],\r\n                position = this.getItemPosition(item);\r\n\r\n            // The fixed item keeps its exact position\r\n            if (\r\n                (fixedItem && item === fixedItem) ||\r\n                !item.dragAndDrop ||\r\n                (!this.options.floating &&\r\n                    this.isItemFloating(item) &&\r\n                    !this.getItemsCollidingWithItem(item).length)\r\n            ) {\r\n                continue;\r\n            }\r\n\r\n            const x = this.findLeftMostPositionForItem(item),\r\n                newPosition = this.findPositionForItem(\r\n                    item,\r\n                    { x: x, y: 0 },\r\n                    position.y\r\n                );\r\n\r\n            this.updateItemPosition(item, newPosition);\r\n        }\r\n    }\r\n\r\n    isOverFixedArea(\r\n        x: number,\r\n        y: number,\r\n        w: number,\r\n        h: number,\r\n        item: GridListItem = null\r\n    ): boolean {\r\n        let itemData = { x, y, w, h };\r\n\r\n        if (this.options.direction !== 'horizontal') {\r\n            itemData = { x: y, y: x, w: h, h: w };\r\n        }\r\n\r\n        for (let i = itemData.x; i < itemData.x + itemData.w; i++) {\r\n            for (let j = itemData.y; j < itemData.y + itemData.h; j++) {\r\n                if (\r\n                    this.grid[i] &&\r\n                    this.grid[i][j] &&\r\n                    this.grid[i][j] !== item &&\r\n                    !this.grid[i][j].dragAndDrop\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    checkItemAboveEmptyArea(\r\n        item: GridListItem,\r\n        newPosition: { x: number; y: number }\r\n    ) {\r\n        let itemData = {\r\n            x: newPosition.x,\r\n            y: newPosition.y,\r\n            w: item.w,\r\n            h: item.h\r\n        };\r\n        if (\r\n            !item.itemPrototype &&\r\n            item.x === newPosition.x &&\r\n            item.y === newPosition.y\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (this.options.direction === 'horizontal') {\r\n            itemData = {\r\n                x: newPosition.y,\r\n                y: newPosition.x,\r\n                w: itemData.h,\r\n                h: itemData.w\r\n            };\r\n        }\r\n        return !this.checkItemsInArea(\r\n            itemData.y,\r\n            itemData.y + itemData.h - 1,\r\n            itemData.x,\r\n            itemData.x + itemData.w - 1,\r\n            item\r\n        );\r\n    }\r\n\r\n    fixItemsPositions(options: IGridsterOptions) {\r\n        // items with x, y that fits gird with size of options.lanes\r\n        const validItems = this.items\r\n            .filter((item: GridListItem) => item.itemComponent)\r\n            .filter((item: GridListItem) =>\r\n                this.isItemValidForGrid(item, options)\r\n            );\r\n        // items that x, y must be generated\r\n        const invalidItems = this.items\r\n            .filter((item: GridListItem) => item.itemComponent)\r\n            .filter(\r\n                (item: GridListItem) => !this.isItemValidForGrid(item, options)\r\n            );\r\n\r\n        const gridList = new GridList([], options);\r\n\r\n        // put items with defined positions to the grid\r\n        gridList.items = validItems.map((item: GridListItem) => {\r\n            return item.copyForBreakpoint(options.breakpoint);\r\n        });\r\n\r\n        gridList.generateGrid();\r\n\r\n        invalidItems.forEach(item => {\r\n            // TODO: check if this change does not broke anything\r\n            // const itemCopy = item.copy();\r\n            const itemCopy = item.copyForBreakpoint(options.breakpoint);\r\n            const position = gridList.findPositionForItem(itemCopy, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n\r\n            gridList.items.push(itemCopy);\r\n            gridList.setItemPosition(itemCopy, position);\r\n            gridList.markItemPositionToGrid(itemCopy);\r\n        });\r\n\r\n        gridList.pullItemsToLeft();\r\n        gridList.pushCollidingItems();\r\n\r\n        this.items.forEach((itm: GridListItem) => {\r\n            const cachedItem = gridList.items.filter(cachedItm => {\r\n                return cachedItm.$element === itm.$element;\r\n            })[0];\r\n\r\n            itm.setValueX(cachedItem.x, options.breakpoint);\r\n            itm.setValueY(cachedItem.y, options.breakpoint);\r\n            itm.setValueW(cachedItem.w, options.breakpoint);\r\n            itm.setValueH(cachedItem.h, options.breakpoint);\r\n            itm.autoSize = cachedItem.autoSize;\r\n        });\r\n    }\r\n\r\n    deleteItemPositionFromGrid(item: GridListItem) {\r\n        const position = this.getItemPosition(item);\r\n        let x, y;\r\n\r\n        for (x = position.x; x < position.x + position.w; x++) {\r\n            // It can happen to try to remove an item from a position not generated\r\n            // in the grid, probably when loading a persisted grid of items. No need\r\n            // to create a column to be able to remove something from it, though\r\n            if (!this.grid[x]) {\r\n                continue;\r\n            }\r\n\r\n            for (y = position.y; y < position.y + position.h; y++) {\r\n                // Don't clear the cell if it's been occupied by a different widget in\r\n                // the meantime (e.g. when an item has been moved over this one, and\r\n                // thus by continuing to clear this item's previous position you would\r\n                // cancel the first item's move, leaving it without any position even)\r\n                if (this.grid[x][y] === item) {\r\n                    this.grid[x][y] = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private isItemFloating(item: any) {\r\n        if (item.itemComponent && item.itemComponent.isDragging) {\r\n            return false;\r\n        }\r\n        const position = this.getItemPosition(item);\r\n\r\n        if (position.x === 0) {\r\n            return false;\r\n        }\r\n        const rowBelowItem = this.grid[position.x - 1];\r\n\r\n        return (rowBelowItem || [])\r\n            .slice(position.y, position.y + position.h)\r\n            .reduce((isFloating, cellItem) => {\r\n                return isFloating && !cellItem;\r\n            }, true);\r\n    }\r\n\r\n    private isItemValidForGrid(item: GridListItem, options: IGridsterOptions) {\r\n        const itemData =\r\n            options.direction === 'horizontal'\r\n                ? {\r\n                      x: item.getValueY(options.breakpoint),\r\n                      y: item.getValueX(options.breakpoint),\r\n                      w: item.getValueH(options.breakpoint),\r\n                      h: Math.min(\r\n                          item.getValueW(this.options.breakpoint),\r\n                          options.lanes\r\n                      )\r\n                  }\r\n                : {\r\n                      x: item.getValueX(options.breakpoint),\r\n                      y: item.getValueY(options.breakpoint),\r\n                      w: Math.min(\r\n                          item.getValueW(this.options.breakpoint),\r\n                          options.lanes\r\n                      ),\r\n                      h: item.getValueH(options.breakpoint)\r\n                  };\r\n\r\n        return (\r\n            typeof itemData.x === 'number' &&\r\n            typeof itemData.y === 'number' &&\r\n            itemData.x + itemData.w <= options.lanes\r\n        );\r\n    }\r\n\r\n    public findDefaultPositionHorizontal(width: number, height: number) {\r\n        for (const col of this.grid) {\r\n            const colIdx = this.grid.indexOf(col);\r\n            let rowIdx = 0;\r\n            while (rowIdx < col.length - height + 1) {\r\n                if (\r\n                    !this.checkItemsInArea(\r\n                        colIdx,\r\n                        colIdx + width - 1,\r\n                        rowIdx,\r\n                        rowIdx + height - 1\r\n                    )\r\n                ) {\r\n                    return [colIdx, rowIdx];\r\n                }\r\n                rowIdx++;\r\n            }\r\n        }\r\n        return [this.grid.length, 0];\r\n    }\r\n\r\n    public findDefaultPositionVertical(width: number, height: number) {\r\n        for (const row of this.grid) {\r\n            const rowIdx = this.grid.indexOf(row);\r\n            let colIdx = 0;\r\n            while (colIdx < row.length - width + 1) {\r\n                if (\r\n                    !this.checkItemsInArea(\r\n                        rowIdx,\r\n                        rowIdx + height - 1,\r\n                        colIdx,\r\n                        colIdx + width - 1\r\n                    )\r\n                ) {\r\n                    return [colIdx, rowIdx];\r\n                }\r\n                colIdx++;\r\n            }\r\n        }\r\n        return [0, this.grid.length];\r\n    }\r\n\r\n    private checkItemsInArea(\r\n        rowStart: number,\r\n        rowEnd: number,\r\n        colStart: number,\r\n        colEnd: number,\r\n        item?: GridListItem\r\n    ) {\r\n        for (let i = rowStart; i <= rowEnd; i++) {\r\n            for (let j = colStart; j <= colEnd; j++) {\r\n                if (\r\n                    this.grid[i] &&\r\n                    this.grid[i][j] &&\r\n                    (item ? this.grid[i][j] !== item : true)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private sortItemsByPosition() {\r\n        this.items.sort((item1, item2) => {\r\n            const position1 = this.getItemPosition(item1),\r\n                position2 = this.getItemPosition(item2);\r\n\r\n            // Try to preserve columns.\r\n            if (position1.x !== position2.x) {\r\n                return position1.x - position2.x;\r\n            }\r\n\r\n            if (position1.y !== position2.y) {\r\n                return position1.y - position2.y;\r\n            }\r\n\r\n            // The items are placed on the same position.\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Some items can have 100% height or 100% width. Those dimmensions are\r\n     * expressed as 0. We need to ensure a valid width and height for each of\r\n     * those items as the number of items per lane.\r\n     */\r\n    private adjustSizeOfItems() {\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            const item = this.items[i];\r\n\r\n            // This can happen only the first time items are checked.\r\n            // We need the property to have a value for all the items so that the\r\n            // `cloneItems` method will merge the properties properly. If we only set\r\n            // it to the items that need it then the following can happen:\r\n            //\r\n            // cloneItems([{id: 1, autoSize: true}, {id: 2}],\r\n            //            [{id: 2}, {id: 1, autoSize: true}]);\r\n            //\r\n            // will result in\r\n            //\r\n            // [{id: 1, autoSize: true}, {id: 2, autoSize: true}]\r\n            if (item.autoSize === undefined) {\r\n                item.autoSize = item.w === 0 || item.h === 0;\r\n            }\r\n\r\n            if (item.autoSize) {\r\n                if (this.options.direction === 'horizontal') {\r\n                    item.h = this.options.lanes;\r\n                } else {\r\n                    item.w = this.options.lanes;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private resetGrid() {\r\n        this.grid = [];\r\n    }\r\n\r\n    /**\r\n     * Check that an item wouldn't overlap with another one if placed at a\r\n     * certain position within the grid\r\n     */\r\n    private itemFitsAtPosition(item: GridListItem, newPosition: [number, number]) {\r\n        const position = this.getItemPosition(item);\r\n        let x, y;\r\n\r\n        // No coordonate can be negative\r\n        if (newPosition[0] < 0 || newPosition[1] < 0) {\r\n            return false;\r\n        }\r\n\r\n        // Make sure the item isn't larger than the entire grid\r\n        if (\r\n            newPosition[1] + Math.min(position.h, this.options.lanes) >\r\n            this.options.lanes\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isOverFixedArea(item.x, item.y, item.w, item.h)) {\r\n            return false;\r\n        }\r\n\r\n        // Make sure the position doesn't overlap with an already positioned\r\n        // item.\r\n        for (x = newPosition[0]; x < newPosition[0] + position.w; x++) {\r\n            const col = this.grid[x];\r\n            // Surely a column that hasn't even been created yet is available\r\n            if (!col) {\r\n                continue;\r\n            }\r\n\r\n            for (y = newPosition[1]; y < newPosition[1] + position.h; y++) {\r\n                // Any space occupied by an item can continue to be occupied by the\r\n                // same item.\r\n                if (col[y] && col[y] !== item) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private updateItemPosition(item: GridListItem, position: [number, number]) {\r\n        if (item.x !== null && item.y !== null) {\r\n            this.deleteItemPositionFromGrid(item);\r\n        }\r\n\r\n        this.setItemPosition(item, position);\r\n\r\n        this.markItemPositionToGrid(item);\r\n    }\r\n\r\n    /**\r\n     * @param Object item A reference to a grid item.\r\n     * @param number width The new width.\r\n     * @param number height The new height.\r\n     */\r\n    private updateItemSize(item: GridListItem, width: number, height: number) {\r\n        if (item.x !== null && item.y !== null) {\r\n            this.deleteItemPositionFromGrid(item);\r\n        }\r\n\r\n        item.w = width;\r\n        item.h = height;\r\n\r\n        this.markItemPositionToGrid(item);\r\n    }\r\n\r\n    /**\r\n     * Mark the grid cells that are occupied by an item. This prevents items\r\n     * from overlapping in the grid\r\n     */\r\n    private markItemPositionToGrid(item: GridListItem) {\r\n        const position = this.getItemPosition(item);\r\n        let x, y;\r\n\r\n        // Ensure that the grid has enough columns to accomodate the current item.\r\n        this.ensureColumns(position.x + position.w);\r\n\r\n        for (x = position.x; x < position.x + position.w; x++) {\r\n            for (y = position.y; y < position.y + position.h; y++) {\r\n                this.grid[x][y] = item;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure that the grid has at least N columns available.\r\n     */\r\n    private ensureColumns(N: number) {\r\n        for (let i = 0; i < N; i++) {\r\n            if (!this.grid[i]) {\r\n                this.grid.push(makeGridCol(this.options.lanes));\r\n            }\r\n        }\r\n    }\r\n\r\n    private getItemsCollidingWithItem(item: GridListItem): number[] {\r\n        const collidingItems = [];\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (\r\n                item !== this.items[i] &&\r\n                this.itemsAreColliding(item, this.items[i])\r\n            ) {\r\n                collidingItems.push(i);\r\n            }\r\n        }\r\n        return collidingItems;\r\n    }\r\n\r\n    private itemsAreColliding(item1: GridListItem, item2: GridListItem) {\r\n        const position1 = this.getItemPosition(item1),\r\n            position2 = this.getItemPosition(item2);\r\n\r\n        return !(\r\n            position2.x >= position1.x + position1.w ||\r\n            position2.x + position2.w <= position1.x ||\r\n            position2.y >= position1.y + position1.h ||\r\n            position2.y + position2.h <= position1.y\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Attempt to resolve the collisions after moving an item over one or more\r\n     * other items within the grid, by shifting the position of the colliding\r\n     * items around the moving one. This might result in subsequent collisions,\r\n     * in which case we will revert all position permutations. To be able to\r\n     * revert to the initial item positions, we create a virtual grid in the\r\n     * process\r\n     */\r\n    private tryToResolveCollisionsLocally(item: GridListItem) {\r\n        const collidingItems = this.getItemsCollidingWithItem(item);\r\n        if (!collidingItems.length) {\r\n            return true;\r\n        }\r\n\r\n        const _gridList = new GridList(\r\n            this.items.map(itm => {\r\n                return itm.copy();\r\n            }),\r\n            this.options\r\n        );\r\n\r\n        let leftOfItem: [number, number];\r\n        let rightOfItem: [number, number];\r\n        let aboveOfItem: [number, number];\r\n        let belowOfItem: [number, number];\r\n\r\n        for (let i = 0; i < collidingItems.length; i++) {\r\n            const collidingItem = _gridList.items[collidingItems[i]],\r\n                collidingPosition = this.getItemPosition(collidingItem);\r\n\r\n            // We use a simple algorithm for moving items around when collisions occur:\r\n            // In this prioritized order, we try to move a colliding item around the\r\n            // moving one:\r\n            // 1. to its left side\r\n            // 2. above it\r\n            // 3. under it\r\n            // 4. to its right side\r\n            const position = this.getItemPosition(item);\r\n\r\n            leftOfItem = [\r\n                position.x - collidingPosition.w,\r\n                collidingPosition.y\r\n            ];\r\n            rightOfItem = [position.x + position.w, collidingPosition.y];\r\n            aboveOfItem = [\r\n                collidingPosition.x,\r\n                position.y - collidingPosition.h\r\n            ];\r\n            belowOfItem = [collidingPosition.x, position.y + position.h];\r\n\r\n            if (_gridList.itemFitsAtPosition(collidingItem, leftOfItem)) {\r\n                _gridList.updateItemPosition(collidingItem, leftOfItem);\r\n            } else if (\r\n                _gridList.itemFitsAtPosition(collidingItem, aboveOfItem)\r\n            ) {\r\n                _gridList.updateItemPosition(collidingItem, aboveOfItem);\r\n            } else if (\r\n                _gridList.itemFitsAtPosition(collidingItem, belowOfItem)\r\n            ) {\r\n                _gridList.updateItemPosition(collidingItem, belowOfItem);\r\n            } else if (\r\n                _gridList.itemFitsAtPosition(collidingItem, rightOfItem)\r\n            ) {\r\n                _gridList.updateItemPosition(collidingItem, rightOfItem);\r\n            } else {\r\n                // Collisions failed, we must use the pullItemsToLeft method to arrange\r\n                // the other items around this item with fixed position. This is our\r\n                // plan B for when local collision resolving fails.\r\n                return false;\r\n            }\r\n        }\r\n        // If we reached this point it means we managed to resolve the collisions\r\n        // from one single iteration, just by moving the colliding items around. So\r\n        // we accept this scenario and merge the branched-out grid instance into the\r\n        // original one\r\n\r\n        this.items.forEach((itm: GridListItem, idx: number) => {\r\n            const cachedItem = _gridList.items.filter(cachedItm => {\r\n                return cachedItm.$element === itm.$element;\r\n            })[0];\r\n\r\n            itm.x = cachedItem.x;\r\n            itm.y = cachedItem.y;\r\n            itm.w = cachedItem.w;\r\n            itm.h = cachedItem.h;\r\n            itm.autoSize = cachedItem.autoSize;\r\n        });\r\n        this.generateGrid();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * When pulling items to the left, we need to find the leftmost position for\r\n     * an item, with two considerations in mind:\r\n     * - preserving its current row\r\n     * - preserving the previous horizontal order between items\r\n     */\r\n    private findLeftMostPositionForItem(item: any) {\r\n        let tail = 0;\r\n        const position = this.getItemPosition(item);\r\n\r\n        for (let i = 0; i < this.grid.length; i++) {\r\n            for (let j = position.y; j < position.y + position.h; j++) {\r\n                const otherItem = this.grid[i][j];\r\n\r\n                if (!otherItem) {\r\n                    continue;\r\n                }\r\n\r\n                const otherPosition = this.getItemPosition(otherItem);\r\n\r\n                if (this.items.indexOf(otherItem) < this.items.indexOf(item)) {\r\n                    tail = otherPosition.x + otherPosition.w;\r\n                }\r\n            }\r\n        }\r\n\r\n        return tail;\r\n    }\r\n\r\n    public findItemByPosition(x: number, y: number): GridListItem {\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (this.items[i].x === x && this.items[i].y === y) {\r\n                return this.items[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getItemByAttribute(key: keyof GridListItem, value: any) {\r\n        for (let i = 0; i < this.items.length; i++) {\r\n            if (this.items[i][key] === value) {\r\n                return this.items[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private padNumber(nr: number, prefix: string) {\r\n        // Currently works for 2-digit numbers (<100)\r\n        return nr >= 10 ? nr : prefix + nr;\r\n    }\r\n\r\n    /**\r\n     * If the direction is vertical we need to rotate the grid 90 deg to the\r\n     * left. Thus, we simulate the fact that items are being pulled to the top.\r\n     *\r\n     * Since the items have widths and heights, if we apply the classic\r\n     * counter-clockwise 90 deg rotation\r\n     *\r\n     *     [0 -1]\r\n     *     [1  0]\r\n     *\r\n     * then the top left point of an item will become the bottom left point of\r\n     * the rotated item. To adjust for this, we need to subtract from the y\r\n     * position the height of the original item - the width of the rotated item.\r\n     *\r\n     * However, if we do this then we'll reverse some actions: resizing the\r\n     * width of an item will stretch the item to the left instead of to the\r\n     * right; resizing an item that doesn't fit into the grid will push the\r\n     * items around it instead of going on a new row, etc.\r\n     *\r\n     * We found it better to do a vertical flip of the grid after rotating it.\r\n     * This restores the direction of the actions and greatly simplifies the\r\n     * transformations.\r\n     */\r\n    private getItemPosition(item: any): { x: number, y: number, w: number, h: number } {\r\n        if (this.options.direction === 'horizontal') {\r\n            return item;\r\n        } else {\r\n            return {\r\n                x: item.y,\r\n                y: item.x,\r\n                w: item.h,\r\n                h: item.w\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * See getItemPosition.\r\n     */\r\n    private setItemPosition(item: any, position: [number, number]) {\r\n        if (this.options.direction === 'horizontal') {\r\n            item.x = position[0];\r\n            item.y = position[1];\r\n        } else {\r\n            // We're supposed to subtract the rotated item's height which is actually\r\n            // the non-rotated item's width.\r\n            item.x = position[1];\r\n            item.y = position[0];\r\n        }\r\n    }\r\n}\r\n"]}